Yi Sun SUN21 1433237

1. For this project, authentication logic implementation has no particular impact since it is just a demo. However, for real-world projects, it is necessary only for a subset of users. The reasons are:
- Some users may use incompatible clients, which will cause the system to crash.
- Some malicious users may attack the system and waste computing resources.
2. The RPC framework should provide full functionality and can be used out of box.
3. For this project, TCP is used for its reliability, which is important for computing processes that require high accuracy. However, its transmission rate is not as good as UDP, which is also important in this process. For real-world projects, QUIC may be a feasible solution since it considers both reliability and transmission rate.
4. The design of rpc_init_client and rpc_init_server is for simplicity in this project. However, for real-world projects, an additional phase to create the socket can be required. Between the initialization of the client/server and the creation of the socket, some work like error checking, etc. can be done.
5. Dynamically. The lifetime of the client and server is controlled dynamically in this project. However, memory leaks are invited. Therefore, Rust is recommended.
6. In this project, network byte order is used in transmission, so there is no need to worry about byte orders. Both the client and server will parse the messages in the proper ways.

Protocol

The protocol is built on TCP, which guarantees reliability. UDP is hard to guarantee reliability despite its speed. Therefore, the UDP version is hard to implement.

1. Find
The client sends find messages to the server to find the handlers:
The first byte of the message is the size of the message.
The second byte of the message is 0, which indicates that this is a find request.
The remaining bytes are the name of the function.

2. Response for find
The server searches the handler list and finds the index for the respective handler:
The first byte of the message is the size of the message.
The second byte of the message is 2, which indicates that this is a handle response.
The third byte of the message is the index of the function.
If the function does not exist, the index -1 is returned, which will be handled by the client properly.

3. Call
The client sends call messages with the payload and index for the functions:
The first byte of the message is the size of the message.
The second byte of the message is 1, which indicates that this is a call request.
The third byte of the message is the size of the size_t.
The fourth byte of the message is the index of the function.
The next **eight** bytes are the data1.
The next sizeof(size_t) bytes are the length of the data2.
The remaining bytes are the data2.
Notice that 8 bytes are used for data1 here for better compatibility.

4. Response for call
The outcome for the call request:
The first byte of the message is the size of the message.
The second byte of the message is the size of the size_t.
The third byte of the message is 3, which indicates that this is a call response.
The next eight bytes of the message is the data1.
The next sizeof(size_t) bytes are the length of the data2.
The remaining bytes are the data2.
If the outcome is NULL, the message is like:
The first byte is the message of the size of the message.
The second byte is 4, which indicates that this is an invalid response that will be handled properly by the client.

The length of the data2 is quite flexible. It is not hardcoded. I think the TCP layer will handle the overlength messages automatically.
